==========
Tue May 07 16:07:21 -0700 2019

Dangerous to commit this to the repo with an indication of (a) the start of work and (b) the apparent total hours spent.

Anyway- I did miss part of the kickoff slideshow but I don't think I missed anything important.

Except maybe what the QNA column means.

==========
Mon May 20 11:38:52 -0700 2019

First- a general plan:

 0. Validate spreadsheets; detect faulty parent-child relationships
 1. Construct product systems (fragments) for each xls sheet
 2. enumerate leaf nodes and terminate them (by hand??) (multiply)
    - I am not going to spend a lot of time researching parts
 3. fragment inventtory to process definition
 4. process upload to OLCA
 5. disclosure

OK, so we've got product systems- now we are dealing with the duplicate assemblies issue.  I am really stumped by the idea of the "normative" solution: how should we deal with this in the "BEST" way? by which I mean: (1) allow the user to determine whether to detect duplicate assemblies, (2) if a duplicate assembly is detected, validate that the duplicate is identical to the original; (3) if the duplicate is not identical to the original, construct an alternate and properly use it; (4) allow input data to be arbitrarily ordered.

We are already not acknowledging (4) because we require a parent to be found in the foreground when the child is created- if it is not, the child node will be created as a reference fragment but the parent relationship will not be restored if the parent is subsequently created.

The problems with the other 3 have mainly to do with the lack of in-place infrastructure to create fragments in a "sandbox" and to delete fragments.  The further problem is that my implementation assumes uniqueness in the way it searches for parent fragments.

Fixed this by adding in a source filter.

OK, so now it seems clear that the simplest way forward is to blindly allow duplicate subassemblies, constrain parents to having the same source sheet, and optionally search for duplicate subassemblies later on.  The wrinkle to that is with nested duplicates- if you have a duplicate subassembly, every subassembly nested under it will also be duplicated-- but if you want to delete duplicates and reuse the primary subassembly, then the duplicate subassembly should get deleted too.  That jusst implies an ordering: the subassemblies should be split off highest-first.

OK, let's give this a try.


==========
Tue May 21 15:17:20 -0700 2019

Foreground built, no problem!

Question for later: the 74A400800-1001 "RETRACT ACTUATOR ASSY" has a QNA of 2 in the reference flow-- how is this to be interpreted?

==========
Wed May 22 13:31:22 -0700 2019

OK.  Revised plan:

 - implement USEEIO-- use Wes's OLCA archive

 - validate USLCI, Ecoinvent 3.5, ELCD on an INVENTORY basis

 - Annotate all the non-assembly parts [i.e. flows that appear on cutoff fragments]
   This is the labor-intensive step-- there are about 800 of them
   = assign a material
   = characterize by mass
   = characterize by whatever reference qty is used in USEEIO (presumably e.g. 2012$USD)
   = identify an appropriate provider for each database:
     - USLCI
     - Ecoinvent 3.5
     - ELCD
     - USEEIO

 - create a new single fragment to contain the various assemblies.
   = Give it a child flow for each distinct non-assembly [i.e. cutoff] part
   = then go through and terminate each child flow to specified provider 



Today's task(s): annotate the flows...

==========
Tue May 28 14:17:07 -0700 2019

OK, so we are down to ginning up terminations for each of the 53 part types we created, for each of the 4 background databases we are using.

We got USEEIO working this morning; EI3.5, USLCI, and ELCD are already working.

We did want to try to use Wes's electricity LCI model but I have not investigated that yet.

Simplest idea: create simple background fragments for each of the 810 parts; terminate them each to 4 different terminations for 4 different LCI data selection scenarios, based on mapping their part types.
 Pros:
  * simple. Can do it in an afternoon
  * can showcase the flow-quantity conversion built into fragment terminations by assigning mass and price to all 810 parts

 Cons:
  * limited to a single background activity per part. This makes it difficult to use, e.g. USLCI, to distinguish between 'steel, hardware' and 'steel, fabricated'
 
Alternate idea: we want to create child fragments for all of the 53 part types that include both "material" and "fabrication" contributions.  BUT we will not do this because of the specific exclusion in the kickoff slide deck: "NOT objectives: Creating original unit processes (except bridge processes)"

So the fragment child flows operate as bridge processes inherently. Only they are way cheaper than processes.

Oh, add to the TODO: aggregate traversal result into process model

Wed 2019-05-29 12:23:56 -0700
Right now we need to come up with a simple way to assign random mass and price to every flow, so that terminations to ....

(see mass_hints)

Thu 2019-05-30 09:45:35 -0700
Well, it wouldn't be an antelope project if it didn't include a desperate 11th-hour discovery of a coding design failure.  In this case a somewhat indeterminate situation with flow characterizations.


Fri 2019-05-31 15:28:41 -0700

Make that 12th-hour.
anyway, all the tests are passing again. now it's time for a 15 hour sprint.

==========
Sun Jun 02 16:17:26 -0700 2019

OK, here's the deal.

We "finished" our termination dictionary, meaning we did USLCI and USEEIO, and the 85% for which ELCD that is not completely outlandishly unsuitable, and decided to skip ecoinvent because we really don't need that to demonstrate the utility of the system.

NOW, all that's left (staged approach):

 - build (by hand) an enclosing fragment for the smallest top-level product system, which is 74A400800-1001.
 - write machinery to mechanistically terminate from the xls dict
 - terminate the enclosing fragment under 2 scenarios
 - validate the disclosure for 2 scenarios [this will include the flow-quantity conversion, but that should be a piece of cake]
 - validate-test the effect of non-matched child flows
 - write a big-enclosing-fragment-builder and terminate it to the various foregrounds
 - terminate the child flows
 - do the big traversal disclosures

Then it's all over but the doco

so let's just do the first few steps on that and see how far we get in 20 min

Sun 2019-06-02 23:17:08 -0700

Checkin:
 X build (by hand) an enclosing fragment for the smallest top-level product system, which is 74A400800-1001.
 X write machinery to mechanistically terminate from the xls dict
 X terminate the enclosing fragment under 2 scenarios
 X validate the disclosure for 2 scenarios [this will include the flow-quantity conversion, but that should be a piece of cake]
 - validate-test the effect of non-matched child flows
 - write a big-enclosing-fragment-builder and terminate it to the various foregrounds
 - terminate the child flows
 - do the big traversal disclosures

not bloody bad

Still to do:
 - test and debug descend
 - cleanup the code a little

